% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ODEsobol.ODEnetwork.R
\name{ODEsobol.ODEnetwork}
\alias{ODEsobol.ODEnetwork}
\title{Sobol' SA for Objects of Class \code{ODEnetwork}}
\usage{
\method{ODEsobol}{ODEnetwork}(mod, pars, times, seed = 2015, n = 1000,
  rfuncs = "runif", rargs = "min = 0, max = 1", sobol_method = "martinez",
  ode_method = "lsoda", ode_parallel = FALSE, ode_parallel_ncores = NA,
  ...)
}
\arguments{
\item{mod}{[\code{ODEnetwork}]\cr
list of class \code{ODEnetwork}.}

\item{pars}{[\code{character(k)}]\cr
vector of \code{k} input variable names. All parameters must be 
contained in \code{names(ODEnetwork::createParamVec(mod))} and must not
be derivable from other parameters supplied (e.g., \code{"k.2.1"} can be 
derived from \code{"k.1.2"}, so supplying \code{"k.1.2"} suffices).}

\item{times}{[\code{numeric}]\cr
points of time at which the SA should be executed (vector of arbitrary 
length). The first point of time must be greater than zero.}

\item{seed}{[\code{numeric(1)}]\cr
seed.}

\item{n}{[\code{integer(1)}]\cr
number of random parameter values (\code{n} per input factor) used to 
estimate the variance-based sensitivity indices by Monte Carlo method.
(Variance-based methods for sensitivity analysis rely on 
Monte Carlo simulation to estimate the integrals needed for the calculation
of the sensitivity indices.) Defaults to 1000.}

\item{rfuncs}{[\code{character(1} or \code{k)}]\cr
names of the functions used to generate the \code{n} random values
for the \code{k} parameters. Can be of length 1 or \code{k}. If of length 
1, the same function is used for all parameters. Defaults to 
\code{"runif"}, so a uniform distribution is assumed for all parameters.}

\item{rargs}{[\code{character(1} or \code{k)}]\cr
arguments to be passed to the functions in \code{rfuncs}. Can be of length 
1 or \code{k}. If of length 1, the same arguments are used for all 
parameters. Each element of \code{rargs} has to be a string of the form 
\code{"tag1 = value1, tag2 = value2, ..."}, see example below. Default is 
\code{"min = 0, max = 1"}, so (together with the default value of 
\code{rfuncs}) a uniform distribution on [0, 1] is assumed for all 
parameters.}

\item{sobol_method}{[\code{character(1)}]\cr
either \code{"jansen"} or \code{"martinez"}, specifying which modification
of the variance-based Sobol' method shall be used. Defaults to 
\code{"martinez"}.}

\item{ode_method}{[\code{character(1)}]\cr
method to be used for solving the differential equations, see 
\code{\link[deSolve]{ode}}. Defaults to \code{"lsoda"}.}

\item{ode_parallel}{[\code{logical(1)}]\cr
logical indicating if a parallelization shall be done for computing the
\code{\link[deSolve]{ode}}-results for the different parameter combinations
generated for Monte Carlo estimation of the sensitivity indices.}

\item{ode_parallel_ncores}{[\code{integer(1)}]\cr
number of processor cores to be used for parallelization. Only applies if
\code{ode_parallel = TRUE}. If set to \code{NA} (as per default) and 
\code{ode_parallel = TRUE}, 1 processor core is used.}

\item{...}{further arguments passed to or from other methods.}
}
\value{
List of length \code{2 * nrow(mod$state)} and of class 
  \code{sobolRes} containing in each element a list of the Sobol' SA results 
  for the corresponding state variable (i.e. first order sensitivity indices
  \code{S} and total sensitivity indices \code{T}) for every point of time of 
  the \code{times} vector.
}
\description{
\code{ODEsobol.ODEnetwork} performs a variance-based sensitivity analysis 
for objects of class \code{ODEnetwork}. Package \code{ODEnetwork} is required
for this function to work.
}
\details{
The sensitivity analysis is done for all state variables and all
  timepoints simultaneously using either
  \code{\link[sensitivity]{soboljansen}} or
  \code{\link[sensitivity]{sobolmartinez}} from the package 
  \code{sensitivity} (depending on 
  \code{sobol_method}). \code{\link[sensitivity]{soboljansen}} and
  \code{\link[sensitivity]{sobolmartinez}} can handle three-dimensional
  arrays as output for their model functions. Each element of the third 
  dimension of the output array is used to contain the results for one 
  state variable of the ODE system. Each element of the second dimension of
  the output array is used for one timepoint. The use of an array as output
  saves time (compared to looping over all state variables and all 
  timepoints) since \code{\link[deSolve]{ode}} from the package 
  \code{deSolve} does its calculations for all state variables and all
  timepoints anyway, so \code{\link[deSolve]{ode}} only needs to be executed 
  once.
}
\note{
It might be helpful to try different types of ODE-solvers (argument 
  \code{ode_method}). Problems are known for the \code{ode_method}s 
  \code{"euler"}, \code{"rk4"} and \code{"ode45"}. 
  In contrast, the \code{ode_method}s \code{"vode"}, \code{"bdf"}, 
  \code{"bdf_d"}, \code{"adams"}, \code{"impAdams"} and \code{"impAdams_d"} 
  might be even faster than the standard \code{ode_method} \code{"lsoda"}.
  
  If \code{n} is too low, the Monte Carlo estimation of the sensitivity 
  indices might be very bad and even produce first order indices < 0 or
  total indices > 1. First order indices in the interval [-0.05, 0) and total 
  indices in (1, 1.05] are considered as minor deviations and set to 0 
  resp. 1 without a warning. First order indices < -0.05 or total indices 
  > 1.05 are considered as major deviations. They remain unchanged and a 
  warning is thrown. Up to now, first order indices > 1 or total indices < 0
  haven't occured yet. If this should be the case, please contact the package
  author.
}
\examples{
##### A network of ordinary differential equations #####
# Definition of the network using the package "ODEnetwork":
library(ODEnetwork)
masses <- c(1, 1)
dampers <- diag(c(1, 1))
springs <- diag(c(1, 1))
springs[1, 2] <- 1
distances <- diag(c(0, 2))
distances[1, 2] <- 1
lfonet <- ODEnetwork(masses, dampers, springs, 
                     cartesian = TRUE, distances = distances)
lfonet <- setState(lfonet, c(0.5, 1), c(0, 0))
LFOpars <- c("m.1", "d.1", "k.1", "k.1.2", "m.2", "d.2", "k.2")
LFOtimes <- seq(0.01, 20, by = 0.1)
LFObinf <- rep(0.001, length(LFOpars))
LFObsup <- c(2, 1.5, 6, 6, 2, 1.5, 6)

LFOres <- ODEsobol(lfonet, 
                   LFOpars, 
                   LFOtimes, 
                   seed = 2015, 
                   n = 1000,
                   rfuncs = c(rep("runif", length(LFObinf)), "rnorm"),
                   rargs = c(paste0("min = ", LFObinf, ", max = ", LFObsup),
                             "mean = 3, sd = 0.8"),
                   sobol_method = "martinez",
                   ode_method = "adams",
                   ode_parallel = TRUE,
                   ode_parallel_ncores = 2)

}
\author{
Frank Weber
}
\seealso{
\code{\link[sensitivity]{soboljansen}, 
  \link[sensitivity]{sobolmartinez},
  \link{plot.sobolRes}}
}

